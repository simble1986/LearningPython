# <center>练习2</center>

<!-- toc -->

> #### info::推荐时间 3天
>
> 可以使用[在线正则表达式](http://tool.oschina.net/regex/)工具进行测试

## 练习目的

在[练习1](1.md)中，我们已经使用了`*`, `+`等**重复**操作符，通过这次练习，熟悉**重复**，**分组**与**分枝条件**的操作，并对之前的内容加以巩固

## 练习内容

我们来写一个匹配IP地址的正则表达式吧。

首先我们先分析一个IP地址，IP地址可以是'1.1.1.1', 也可以是'111.111.111.111'。那么，我们可以用`\d+\.\d+\.\d+\.\d+`。

或许你已经注意到了，我们有3个`\d+\.`，那么可以简化为`(\d+\.){3}\d+`。

**那么，这样就对了么**?试试'333.333.333.333'，还有'3333.3333.3333.3333'，也能用这个正则来命中

事实是，你会发现，如果要通过正则表达式来完美的匹配一个IP地址，远比你想象的要复杂的多的多。

1. 使用一个正则表达式匹配'0'到'9'
2. 使用一个正则表达式来匹配'10'到'99'
3. 使用一个正则表达式来匹配'100', '123', '157', '199'等
4. 使用一个正则表达式来匹配'200', '210', '249'等
5. 使用一个正则表达式来匹配'250', '251', '252', '253', '254'和'255'

**到这里，你有没有发现我们已经对0-255之间的数字都进行了匹配**

那么，尝试使用一个正则表达式来完成IP地址匹配吧

## 练习要求

使用正则表达式完成，可使用在线正则表达式测试

## 相关知识点

### 重复

代码 | 说明 | 举例
---- | ---- | ----
`*` | 重复0次或多次 | `\d*`可匹配'', '1', '22', '333', '4444' ...
`+` | 重复1次或多次 | `\d+`可匹配'1', '22', '333', '4444' ...
`?` | 重复0次或1次 | `\d?`可匹配''或'1', '2', '3' ...
`{n}` | 重复n次 | `\d{3}`可匹配'111', '222', '333', '444'...
`{n,}` | 重复n次或更多 | `\d{3,}`可匹配'333', '4444', '55555' ... 不可匹配'1', '22' ...
`{n,m}` | 重复n到m次 | `\d{3,4}`可匹配'333', '4444'等，不可匹配'22', '55555'等

### 分组

为单个字符后面加上重复次数，便可以匹配多个字符，但要为多个字符增加重复次数呢？可以使用`()`来对正则表达式进行分组

* 举例

1. `(abc)+`匹配的是'abcabcabc'，而`abc+`匹配的是'abcccccc'

**分组的一个重要用途是捕获**

### 反向引用

使用`()`对正则进行分组后，匹配了'()'里面的正则表达式的文本可以在表达式或其它程序中作进一步的处理。

默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。

* 举例

`(\w+)\s+\1`，表示匹配一个*单词+空格+单词*，且前后两个单词是一样的。即'hi hi', 'hello   hello'

也可以自己指定**组名**。要指定组名，可以使用这样的语法：'(?<key>\w+)'，那么上面的表达式可以写作`(?<aa>\w+)\s+\k<aa>`。这里的`\k`相当与正则表达式的关键字


### 分支条件

正则表达式的分支条件，指的是有几种规则，只要有一种一条满足都能够匹配成功。具体的方法是用`|`来隔开。你可以用'或'来理解它。

**注意** `|`的优先级较高，所以`g|food`可以匹配的是'g'或'food'，而不是'good'或'food'，如果要匹配'good'或'food'，则必须使用`(g|f)ood`

* 举例

1. `0|1`匹配0或者1，当然，你也可以写成`[01]`
2. `(P|p)assword:`匹配'password'或'Password'
3. `(1[0-9])|(2[0-5])|([0-9])`可以匹配0-25的数字，你不妨试试看

### 小括号的使用

使用`()`还有一些特定的用途，以下是一些常用的

<table>
<thead>
<tr>
<th>分类</th>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="3">捕获</td>
<td><code>(exp)</code></td>
<td>匹配exp,并捕获文本到自动命名的组里</td>
</tr>
<tr>
<td><code>(?<name>exp)</code></td>
<td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)</td>
</tr>
<tr>
<td><code>(?:exp)</code></td>
<td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>
</tr>
<tr>
<td rowspan="4">零宽断言</td>
<td><code>(?=exp)</code></td>
<td>匹配exp前面的位置</td>
</tr>
<tr>
<td><code>(?<=exp)</code></td>
<td>匹配exp后面的位置</td>
</tr>
<tr>
<td><code>(?!exp)</code></td>
<td>匹配后面跟的不是exp的位置</td>
</tr>
<tr>
<td><code>(?<!exp)</code></td>
<td>匹配前面不是exp的位置</td>
</tr>
<tr>
<td>注释</td>
<td><code>(?#comment)</code></td>
<td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>
</tr>
</tbody>
</table>

## 思考

我们有没有必要使用那么复杂的正则来匹配IP地址？

在python中有没有更好的办法来识别一个字符串是不是一个合法的IP地址？